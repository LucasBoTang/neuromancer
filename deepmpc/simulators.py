
import torch
import torch.nn as nn
import numpy as np
from emulators import EmulatorBase
from logger import BasicLogger
from visuals import Visualizer
from problem import Problem
from datasets import Dataset


class Simulator:
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        self.model = model
        self.dataset = dataset
        self.emulator = emulator

    def dev_eval(self):
        pass

    def test_eval(self):
        pass

    def simulate(self):
        pass

    # def select_step_data(self, i):
    #     # for closed loop we want to pick k-th batch of the nstep data nstep_data[item][:, k, :]
    #     step_data = dict()
    #     for k, v in self.dataset.nstep_data.items():
    #         step_data[k] = v[:, i, :]
    #     return step_data
    #
    # def simulate(self, ninit=0, nsim=None):
    #     self.model.eval()
    #     self.ninit = ninit
    #     self.nsim = self.dataset.loop_data['Yp'].shape[0] if nsim is None else nsim
    #
    #     if self.dataset.type == 'closedloop':
    #         # TODO: for MPC we need to have moving horizon dataset
    #         # CL eval steps:
    #         # 1, initialize emulator with initial conditions and initial input trajectories
    #         # 2, obtain i-th step batch of nstep data generated by emulator
    #         # 3, forward pass i-th step batch through the model
    #         # 4, receding horizon - slect only first sampling instant of the i-th batch control actions
    #         # 5, simulate amulator with selected control actions and obtain new step batch - continue from step 2,
    #
    #         for i in range(self.ninit, self.nsim):
    #             step_data = self.select_step_data(i)
    #             step_output = self.model(step_data)
    #             # TODO: how to link with the emulator or learned dynamics model?
    #
    # #
    #     elif self.dataset.type == 'openloop':
    #         all_output = dict()
    #         for data, dname in zip([self.dataset.train_loop, self.dataset.dev_loop, self.dataset.test_loop],
    #                                ['train', 'dev', 'test']):
    #             all_output = {**all_output, **self.model(data)}
    #         plots = self.visualizer.eval(all_output)
    #         self.logger.log_artifacts(plots)


class OpenLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)

    def dev_eval(self):
        dev_loop_output = self.model(self.dataset.dev_loop)
        return dev_loop_output

    def test_eval(self):
        all_output = dict()
        for data, dname in zip([self.dataset.train_loop, self.dataset.dev_loop, self.dataset.test_loop],
                               ['train', 'dev', 'test']):
            all_output = {**all_output, **self.model(data)}
        return all_output

    def simulate(self, dataset):
        pass
