"""


TODO: handle pytorch model as emulator
TODO: overwrite past after n-steps, continuously in first n steps
TODO: consistent parameters() call for emulators
TODO: finish eval with model and emulator
TODO: eval_metric - evaluate closed loop metric based on the simulation results

"""
import torch
import torch.nn as nn
from emulators import EmulatorBase
from datasets import EmulatorDataset, FileDataset, min_max_denorm
from problem import Problem
from datasets import Dataset, DataDict
from collections import defaultdict
import numpy as np

class Simulator:
    def __init__(self, model: Problem, dataset: Dataset, emulator: EmulatorBase = None):
        self.model = model
        self.dataset = dataset
        self.emulator = emulator

    def dev_eval(self):
        dev_loop_output = self.model(self.dataset.dev_loop)
        # dev_loop_output = self.simulate(self.dataset.dev_loop)
        return dev_loop_output

    def test_eval(self):
        all_output = dict()
        for data, dname in zip([self.dataset.train_loop, self.dataset.dev_loop, self.dataset.test_loop],
                               ['train', 'dev', 'test']):
            all_output = {**all_output, **self.simulate(data)}
        return all_output

    def simulate(self):
        pass


class OpenLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)

    def simulate(self, data):
        return self.model(data)


class ClosedLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)
        assert isinstance(emulator, EmulatorBase) or isinstance(emulator,  nn.Module), \
            f'{type(emulator)} is not EmulatorBase or nn.Module.'
        self.emulator = emulator
        self.ninit = 0
        self.nsim = self.dataset.nstep_data['Yf'].shape[1]
        self.emulator.parameters() if isinstance(emulator, EmulatorBase) else None
        if isinstance(emulator, EmulatorBase):
            self.x0 = self.emulator.x0
        elif isinstance(emulator, nn.Module):
            self.x0 = torch.zeros([1, self.emulator.nx])

    def select_step_data(self, data, i):
        """
        for closed loop we want to pick i-th batch of the nstep data nstep_data[item][:, k, :]

        :param data:
        :param i:
        :return:
        """
        step_data = DataDict()
        for k, v in data.items():
            step_data[k] = v[:, i, :].reshape(v.shape[0], 1, v.shape[2])
        step_data.name = data.name
        return step_data

    def eval_metric(self):
        pass

    def simulate(self, data):
        """
          # CL eval steps:
          # 1, initialize emulator with initial conditions and initial input trajectories
          # 2, obtain i-th simulation step batch of nstep data generated by emulator
          # 3, forward pass i-th step batch through the model
          # 4, receding horizon - slect only first sampling instant of the i-th batch control actions
          # 5, simulate emulator with selected control actions and obtain new step batch - continue from step 2,

        :param data:
        :return:
        """
        self.model.eval()
        self.nsim = data['Yp'].shape[1]
        self.nsteps = data['Yp'].shape[0]
        Y, X, D, U = [], [], [], []  # emulator trajectories
        Y_pred, X_pred, U_pred, U_opt = [], [], [], []   # model  trajectories
        for i in range(self.nsim):
            step_data = self.select_step_data(data, i)

            x = self.x0 if i == 0 else x
            if i > 0:
                # select current step disturbance
                dist = step_data['Df'][0].detach().numpy() if step_data['Df'] is not None else None
                if 'D' in self.dataset.norm:
                    d = min_max_denorm(dist, self.dataset.min_max_norms['Dmin'],
                                       self.dataset.min_max_norms['Dmax']) if dist is not None else None
                else:
                    d = dist
                # simulate 1 step of the emulator model
                if isinstance(self.emulator, EmulatorBase):
                    x, y, _, _ = self.emulator.simulate(ninit=0, nsim=1, U=u, D=d, x0=x.flatten())
                elif isinstance(self.emulator, nn.Module):
                    step_data_0 = dict()
                    step_data_0['U_pred'] = uopt
                    step_data_0['x0'] = x
                    for k, v in step_data.items():
                        step_data_0[k] = v[0]
                    emulator_output = self.emulator(step_data_0)
                    x = emulator_output['X_pred'][0]
                    y = emulator_output['Y_pred'][0]
                # update u and y trajectory history
                if len(Y) > self.nsteps:
                    if 'Y' in self.dataset.norm and isinstance(self.emulator, EmulatorBase):
                        Yp_np, _, _ = self.dataset.normalize(np.concatenate(Y[-self.nsteps:]),
                                                             Mmin=self.dataset.min_max_norms['Ymin'],
                                                             Mmax=self.dataset.min_max_norms['Ymax'])
                    else:
                        Yp_np = np.concatenate(Y[-self.nsteps:])
                    step_data['Yp'] = torch.tensor(np.concatenate(Yp_np, 0)).reshape(self.nsteps, 1, -1)

                if len(U_opt) > self.nsteps:
                    step_data['Up'] = torch.cat(U_opt[-self.nsteps:], dim=0).reshape(self.nsteps, 1, -1)

            # control policy model
            step_output = self.model(step_data)

            # model trajectories
            x_key = [k for k in step_output.keys() if 'X_pred' in k]
            X_pred.append(step_output[x_key[0]])
            y_key = [k for k in step_output.keys() if 'Y_pred' in k]
            Y_pred.append(step_output[y_key[0]])
            u_key = [k for k in step_output.keys() if 'U_pred' in k]
            U_pred.append(step_output[u_key[0]])
            uopt = step_output[u_key[0]][0]
            U_opt.append(uopt)

            # emulator trajectories
            if 'U' in self.dataset.norm:
                u = min_max_denorm(uopt.detach().numpy(), self.dataset.min_max_norms['Umin'],
                                   self.dataset.min_max_norms['Umax'])
            else:
                u = uopt.detach().numpy()
            if i > 0:
                U.append(u)
                Y.append(y) if isinstance(self.emulator, EmulatorBase) else Y.append(y.detach().numpy())
                X.append(x) if isinstance(self.emulator, EmulatorBase) else X.append(x.detach().numpy())
                D.append(d) if d is not None else None

        return {'X_pred': torch.cat(X_pred, dim=1), 'Y_pred': torch.cat(Y_pred, dim=1),
                'U_pred': torch.cat(U_pred, dim=1), 'U_opt': torch.cat(U_opt, dim=0),
                'Y': np.concatenate(Y, 0), 'X': np.concatenate(X, 0),
                'U': np.concatenate(U, 0), 'D': np.concatenate(D, 0) if D is not None else None}


if __name__ == '__main__':

    systems = {'Reno_full': 'emulator'}
    for system, data_type in systems.items():
        if data_type == 'emulator':
            dataset = EmulatorDataset(system)
        elif data_type == 'datafile':
            dataset = FileDataset(system)
    nsim, ny = dataset.data['Y'].shape
    nu = dataset.data['U'].shape[1]
    dataset.make_nstep()
    dataset.make_loop()

    # model = None
    # emulator = None
    # simulator = ClosedLoopSimulator(model=model, dataset=dataset, emulator=emulator)
