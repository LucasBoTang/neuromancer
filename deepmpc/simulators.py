
import torch
import torch.nn as nn
import numpy as np
from emulators import EmulatorBase
from datasets import EmulatorDataset, FileDataset
import emulators
from logger import BasicLogger
from visuals import Visualizer
from problem import Problem
from datasets import Dataset, DataDict

class Simulator:
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        self.model = model
        self.dataset = dataset
        self.emulator = emulator

    def dev_eval(self):
        pass

    def test_eval(self):
        pass

    def simulate(self):
        pass


class OpenLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)

    def dev_eval(self):
        dev_loop_output = self.model(self.dataset.dev_loop)
        return dev_loop_output

    def test_eval(self):
        all_output = dict()
        for data, dname in zip([self.dataset.train_loop, self.dataset.dev_loop, self.dataset.test_loop],
                               ['train', 'dev', 'test']):
            all_output = {**all_output, **self.model(data)}
        return all_output

    def simulate(self, data):
        pass


class ClosedLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)
        self.ninit = 0
        self.nsim = self.dataset.nstep_data['Yf'].shape[1]

        if isinstance(self.emulator, EmulatorBase):
            if isinstance(self.emulator, emulators.GymWrapper):
                self.emulator.parameters(system=self.system)
            elif isinstance(self.emulator, emulators.BuildingEnvelope):
                self.emulator.parameters(system=self.system, linear=True)
            else:
                self.emulator.parameters()


        #         # TODO: for MPC we need to have moving horizon dataset
    #         # CL eval steps:
    #         # 1, initialize emulator with initial conditions and initial input trajectories
    #         # 2, obtain i-th simulation step batch of nstep data generated by emulator
    #         # 3, forward pass i-th step batch through the model
    #         # 4, receding horizon - slect only first sampling instant of the i-th batch control actions
    #         # 5, simulate emulator with selected control actions and obtain new step batch - continue from step 2,
    #
    #         for i in range(self.ninit, self.nsim):
    #             step_data = self.select_step_data(i)
    #             step_output = self.model(step_data)
    #             # TODO: how to link with the emulator or learned dynamics model?
    #

    def select_step_data(self, i):
        # for closed loop we want to pick i-th batch of the nstep data nstep_data[item][:, k, :]
        step_data = DataDict()
        for k, v in self.dataset.dev_data.items():
            step_data[k] = v[:, i, :].reshape(v.shape[0], 1, v.shape[2])
        step_data.name = self.dataset.dev_data.name
        # step_dataset = Dataset(sequences=step_data, name='closedloop')
        return step_data

    # TODO: define eval methods on mh datasets called as train_loop
    def dev_eval(self):
        pass

    def test_eval(self):
        pass

    def simulate(self, dataset):
        self.nsim = dataset.nstep_data['Yp'].shape[1]

        # # nominal initial data
        # X, Y, U, D = self.emulator.simulate(ninit=0, nsim=dataset.nsteps,
        #                                     U=self.dataset.dev_data['Uf'],
        #                                     D=self.dataset.dev_data['Df'])  # simulate open loop

        U_opt_trajectory = []
        U_opt = []
        Y = []
        D = []
        Step_outputs = []
        for i in range(self.nsim):
            step_data = self.select_step_data(dataset, i)

            if i > 0:
                d = step_data['Df'][0]
                x, y, _, _ = self.emulator.simulate(ninit=0, nsim=1, U=uopt,
                                                    D=d)  # simulate open loop
                step_data['Yp'] = y
                step_data['Up'] = uopt

            step_output = self.model(step_data)
            Step_outputs.append(step_output)
            ctrl_key = [k for k in step_output.keys() if 'U_pred' in k]
            uopt_trajectory = step_output[ctrl_key[0]]
            uopt = uopt_trajectory[0]
            U_opt_trajectory.append(uopt_trajectory)
            U_opt.append(uopt)
            Y.append(y)
            D.append(d)

        # TODO: pugt stuff in Step_outputs back together
        # Step_outputs =
        return {'U_opt': torch.cat(U_opt), 'Y_opt': torch.tensor(np.concatenate(Y)), **Step_outputs}

# TODO:  I/O of the simulator should be a torch tensor'
# TODO: wrapper for nn.Modules as emulators

# # # EXAMPLE control step evaluate
# step_output = model(dataset.dev_data)
# ctrl_key = [k for k in step_output.keys() if 'U_pred' in k]
# uopt_trajectory = step_output[ctrl_key[0]]
# uopt_step0 = uopt_trajectory[0]


if __name__ == '__main__':

    systems = {'Reno_full': 'emulator'}
    for system, data_type in systems.items():
        if data_type == 'emulator':
            dataset = EmulatorDataset(system)
        elif data_type == 'datafile':
            dataset = FileDataset(system)
    nsim, ny = dataset.data['Y'].shape
    nu = dataset.data['U'].shape[1]
    dataset.make_nstep()
    dataset.make_loop()

    # TODO: finish eval with model and emulator
    model = None
    emulator = None
    simulator = ClosedLoopSimulator(model=model, dataset=dataset, emulator=emulator)
