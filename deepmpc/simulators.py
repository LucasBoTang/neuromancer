
import torch
import torch.nn as nn
import numpy as np
from emulators import EmulatorBase
from datasets import EmulatorDataset, FileDataset
import emulators
from logger import BasicLogger
from visuals import Visualizer
from problem import Problem
from datasets import Dataset, DataDict

class Simulator:
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        self.model = model
        self.dataset = dataset
        self.emulator = emulator

    def dev_eval(self):
        pass

    def test_eval(self):
        pass

    def simulate(self):
        pass


class OpenLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)

    def dev_eval(self):
        dev_loop_output = self.model(self.dataset.dev_loop)
        return dev_loop_output

    def test_eval(self):
        all_output = dict()
        for data, dname in zip([self.dataset.train_loop, self.dataset.dev_loop, self.dataset.test_loop],
                               ['train', 'dev', 'test']):
            all_output = {**all_output, **self.model(data)}
        return all_output

    def simulate(self, dataset):
        pass


class ClosedLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)
        self.ninit = 0
        self.nsim = self.dataset.nstep_data['Yf'].shape[1]

        if self.emulator is not None:
            if isinstance(self.emulator, emulators.GymWrapper):
                self.emulator.parameters(system=self.system)
            elif isinstance(self.emulator, emulators.BuildingEnvelope):
                self.emulator.parameters(system=self.system, linear=True)
            else:
                self.emulator.parameters()


        #         # TODO: for MPC we need to have moving horizon dataset
    #         # CL eval steps:
    #         # 1, initialize emulator with initial conditions and initial input trajectories
    #         # 2, obtain i-th step batch of nstep data generated by emulator
    #         # 3, forward pass i-th step batch through the model
    #         # 4, receding horizon - slect only first sampling instant of the i-th batch control actions
    #         # 5, simulate amulator with selected control actions and obtain new step batch - continue from step 2,
    #
    #         for i in range(self.ninit, self.nsim):
    #             step_data = self.select_step_data(i)
    #             step_output = self.model(step_data)
    #             # TODO: how to link with the emulator or learned dynamics model?
    #

    def select_step_data(self, i):
        # for closed loop we want to pick k-th batch of the nstep data nstep_data[item][:, k, :]
        step_data = DataDict()
        for k, v in self.dataset.dev_data.items():
            step_data[k] = v[:, i, :].reshape(v.shape[0], 1, v.shape[2])
        step_data.name = self.dataset.dev_data.name
        # step_dataset = Dataset(sequences=step_data, name='closedloop')
        return step_data

    def dev_eval(self):
        pass

    def test_eval(self):
        pass

    def simulate(self, ninit=0, nsim=1):
        self.ninit = ninit
        self.nsim = nsim
        for i in range(self.ninit, self.nsim):
            step_data = self.select_step_data(i)
            step_output = self.model(step_data)
            ctrl_key = [k for k in step_output.keys() if 'U_pred' in k]
            uopt_trajectory = step_output[ctrl_key[0]]
            uopt = uopt_trajectory[0]

            X, Y, U, D = self.emulator.simulate(ninit=self.ninit, nsim=self.nsim)  # simulate open loop
            sim_data = dict()
            for d, k in zip([Y, U, D], ['Y', 'U', 'D']):
                sim_data[k] = d if d is not None else None


# # EXAMPLE control step evaluate
# step_output = model(dataset.dev_data)
# ctrl_key = [k for k in step_output.keys() if 'U_pred' in k]
# uopt_trajectory = step_output[ctrl_key[0]]
# uopt_step0 = uopt_trajectory[0]


if __name__ == '__main__':

    systems = {'Reno_full': 'emulator'}
    for system, data_type in systems.items():
        if data_type == 'emulator':
            dataset = EmulatorDataset(system)
        elif data_type == 'datafile':
            dataset = FileDataset(system)
    nsim, ny = dataset.data['Y'].shape
    nu = dataset.data['U'].shape[1]
    dataset.make_nstep()
    dataset.make_loop()

    # TODO: finish eval with model and emulator
    model = None
    emulator = None
    simulator = ClosedLoopSimulator(model=model, dataset=dataset, emulator=emulator)
