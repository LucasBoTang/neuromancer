"""

"""
import torch
import torch.nn as nn
from emulators import EmulatorBase
from datasets import EmulatorDataset, FileDataset, min_max_denorm
from problem import Problem
from datasets import Dataset, DataDict
from collections import defaultdict
import numpy as np

class Simulator:
    def __init__(self, model: Problem, dataset: Dataset, emulator: EmulatorBase = None):
        self.model = model
        self.dataset = dataset
        self.emulator = emulator

    def dev_eval(self):
        dev_loop_output = self.model(self.dataset.dev_loop)
        # dev_loop_output = self.simulate(self.dataset.dev_loop)
        return dev_loop_output

    def test_eval(self):
        all_output = dict()
        for data, dname in zip([self.dataset.train_loop, self.dataset.dev_loop, self.dataset.test_loop],
                               ['train', 'dev', 'test']):
            all_output = {**all_output, **self.simulate(data)}
        return all_output

    def simulate(self):
        pass


class OpenLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)

    def simulate(self, data):
        return self.model(data)


class ClosedLoopSimulator(Simulator):
    def __init__(self, model: Problem, dataset: Dataset, emulator: [EmulatorBase, nn.Module] = None):
        super().__init__(model=model, dataset=dataset, emulator=emulator)
        assert isinstance(emulator, EmulatorBase), f'{type(emulator)} is not EmulatorBase.'
        self.emulator = emulator
        self.ninit = 0
        self.nsim = self.dataset.nstep_data['Yf'].shape[1]
        self.emulator.parameters()
        # TODO: consistent parameters() call for emulators


    def select_step_data(self, data, i):
        """
        for closed loop we want to pick i-th batch of the nstep data nstep_data[item][:, k, :]

        :param data:
        :param i:
        :return:
        """
        step_data = DataDict()
        for k, v in data.items():
            step_data[k] = v[:, i, :].reshape(v.shape[0], 1, v.shape[2])
        step_data.name = data.name
        return step_data

    def eval_metric(self):
        # TODO: evaluate closed loop metric based on the simulation results
        pass

    def simulate(self, data):
        """
          # CL eval steps:
          # 1, initialize emulator with initial conditions and initial input trajectories
          # 2, obtain i-th simulation step batch of nstep data generated by emulator
          # 3, forward pass i-th step batch through the model
          # 4, receding horizon - slect only first sampling instant of the i-th batch control actions
          # 5, simulate emulator with selected control actions and obtain new step batch - continue from step 2,

        :param data:
        :return:
        """
        self.model.eval()
        self.nsim = data['Yp'].shape[1]
        self.nsteps = data['Yp'].shape[0]
        Y, X, D, U = [], [], [], []  # emulator trajectories
        Y_pred, X_pred, U_pred, U_opt = [], [], [], []   # model  trajectories
        # Step_outputs = defaultdict(list)
        for i in range(self.nsim):
            step_data = self.select_step_data(data, i)
            dist = step_data['Df'][0].detach().numpy() if step_data['Df'] is not None else None
            if 'D' in self.dataset.norm:
                d = min_max_denorm(dist, self.dataset.min_max_norms['Dmin'], self.dataset.min_max_norms['Dmax']) if dist is not None else None
            else:
                d = dist
            if i > 0:
                x, y, _, _ = self.emulator.simulate(ninit=0, nsim=1, U=u, D=d)
                # overwrite past after n-steps, TODO: owevreite continuously in first n steps
                if len(Y) > self.nsteps:
                    if 'Y' in self.dataset.norm:
                        Yp_np, _, _ = self.dataset.normalize(np.concatenate(Y[-self.nsteps:]), Mmin=self.dataset.min_max_norms['Ymin'],
                                                         Mmax=self.dataset.min_max_norms['Ymax'])
                    else:
                        Yp_np = np.concatenate(Y[-self.nsteps:])
                    step_data['Yp'] = torch.tensor(np.concatenate(Yp_np, 0)).reshape(self.nsteps, 1, -1)
                if len(U_opt) > self.nsteps:
                    step_data['Up'] = torch.cat(U_opt[-self.nsteps:], dim=0).reshape(self.nsteps, 1, -1)

            #     TODO: handle pytorch model as emulator
            step_output = self.model(step_data)
            # for k, v in step_output.items():
            #     Step_outputs[k].append(v)

            # model trajectories
            x_key = [k for k in step_output.keys() if 'X_pred' in k]
            X_pred.append(step_output[x_key[0]])
            y_key = [k for k in step_output.keys() if 'Y_pred' in k]
            Y_pred.append(step_output[y_key[0]])
            u_key = [k for k in step_output.keys() if 'U_pred' in k]
            U_pred.append(step_output[u_key[0]])
            uopt = step_output[u_key[0]][0]
            U_opt.append(uopt)

            # emulator trajectories
            if 'U' in self.dataset.norm:
                u = min_max_denorm(uopt.detach().numpy(), self.dataset.min_max_norms['Umin'],
                                   self.dataset.min_max_norms['Umax'])
            else:
                u = uopt.detach().numpy()
            if i > 0:
                U.append(u)
                Y.append(y)
                X.append(x)
                D.append(d) if d is not None else None

        return {'X_pred': torch.cat(X_pred, dim=1), 'Y_pred': torch.cat(Y_pred, dim=1),
                'U_pred': torch.cat(U_pred, dim=1), 'U_opt': torch.cat(U_opt, dim=0),
                'Y': np.concatenate(Y, 0), 'X': np.concatenate(X, 0),
                'U': np.concatenate(U, 0), 'D': np.concatenate(D, 0) if D is not None else None}

        # Step_outputs = {torch.cat(v) for k, v in Step_outputs}
        # return Step_outputs
        # #     TODO: dimensions in torch.cat(v) are insonsistent

if __name__ == '__main__':

    systems = {'Reno_full': 'emulator'}
    for system, data_type in systems.items():
        if data_type == 'emulator':
            dataset = EmulatorDataset(system)
        elif data_type == 'datafile':
            dataset = FileDataset(system)
    nsim, ny = dataset.data['Y'].shape
    nu = dataset.data['U'].shape[1]
    dataset.make_nstep()
    dataset.make_loop()

    # TODO: finish eval with model and emulator
    # model = None
    # emulator = None
    # simulator = ClosedLoopSimulator(model=model, dataset=dataset, emulator=emulator)
